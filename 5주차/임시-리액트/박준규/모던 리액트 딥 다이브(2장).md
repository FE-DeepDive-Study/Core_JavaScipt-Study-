
# 리액트 핵심 요소 깊게 살펴보기

## JSX

자바스크립트에서 표현하기 힘든 XML 스타일의 트리구문을 작성을 간편하게 한 문법

### JSX의 정의

JSXElement, JSXAttributes, JSXChildren, JSXString 로 구성

- JSXElement (HTML element 와 비슷한 역할)
    - JSXOpeningElement: `<JSXElement JSXAttributes(optional)>`
    - JSXClosingElement: `<JSXElement />`
    - JSXSelfClosingElement: `<JSXElement JSXAttributes(optional) />`
    - JSXFragment: `<>JSXChildren(optional)</>`
    - JSXEIementName
        - JSXIdentifier : 자바스크립트 식별자와 같은 규칙, 숫자, $,_ 가 아닌 특수문자로 시작할 수 없는 단어
        - JSXNamespacedName: JSXIdentifier`:`JSXIdentifier의 조합
            - 여러 개 조합 불가
        - JSXMemberExpression: JSXIdentifier`.`JSXIdentifier의 조합
            - 여러 개 조합 가
- JSXAttributes
    - 부여할 수 있는 속성을 의미
    - JSXSpreadAttributes
        `{...AssignmentExpression}`
    - JSXAttribute (속성)
        - 키: JSXAttributeName
        - 값: JSXAttributeValue
- JSXChildren (자식)
    - JSXElement의 자식 값을 나타냄. JSX로 부모와 자식 관계를 나타낼 수 있다. JSXChild가 0개 이상이어야 함
    - JSXStrings
        HTML과JSX 사이에 복사와 붙여넣기를 쉼게 할 수 있도록 설계돼 있다


    

### JSX 예제

```js
// 하나의 요소로 구성된 가장 단순한 형태
const ComponentA = <A>안녕하세요.<M>

// 자식이 없이 SelfClosingTag로 닫혀 있는 형태도 가능하다.
const ComponentB = <A />

// 옵션을 { }와 전개 연산자로 넣을 수 있다
const ComponentC = <A {...{ required: true }} />

// 속성만 넣어도 가능하다.
const ComponentD = <A required />

// 속성과 속성값을 넣을 수 있다.
const ComponentE = <A required={false} />

const ComponentF = (
    <A>
        {/* 문자열은 큰따옴표 및 작은따옴표 모두 가능하다. */}
        <B text="리액트" />
    </A>
)

const ComponentG = (
    <A>
        {/* 옵션의 값으로 JSXElement률 넣는 것 또한 올바른 문법이다. */}
        <B optionalChildren={<>안녕하세요.</>} />
    </A>
)

const ComponentH = (
    <A>
        {/* 여러 개의 자식도 포함할 수 있다. */}
        안녕하세요
        <B text="리액트" />
    </A>
)
```

### JSX는 어떻게 자바스크립트에서 변환될까

`@babel/plugin-transform-react-jsx`

- JSX는 자바스크립트 코드 내부에 HTML과 같은 트리 구조를 가진 컴포넌트를 표현할 수 있다는 점에서 각광받고 있다. 
- 물론 인기만 있는 것은 아니다. JSX가 HTML 문법과 자바스크립트 문법이 뒤섞여서 코드
가독성을 해친다는 의견도 있다. JSX 내부에 자바스크립트 문법이 많아질수록 복잡성이 증대하면서 코드의 가독성도 해칠 것이므로 주의해서 사용해야 한다.
- 그리고 적어도 리액트 내부에서 JSX가 어떻게 변환되는지, 그리고 어떤 결과물을 만들어내는지 알아두면 향후에 리액트 애플리케이션을 만드는 데 도움이 될 수 있다. 
- JSX는 물론 대부분의 경우 편리하고 간결하게 컴포넌트를 작성하는 데 많은 도움을 주지만 앞선 예제처럼 때에 따라서는 직접 createElemnt를 사용해 컴포넌트를 구성하는 편이 더 효율적일 수 있다.
- 이러한 JSX에 대한 깊은 이해도는 나아가 리액트와 비슷한 JSX 기반의 또 다른 애플리케이션을 만드는 데 도움이 될 것이다.

## 가상 DOM과 리액트 파이버

가상 DOM과 리액트의 핵심은 브라우저의 DOM을 더욱 빠르게 그리고 반영하는 것이 아니라 바로 값으로 UI를 표현하는 것이다. 화면에 표시되는 이를 자바스크립트의 문자열, 배열 등과 마찬가지로 값으로 관리하고 이러한 흐름을 효율적으로 관리하기 위한 메커니즘이 바로 리액트의 핵심이다.


### DOM과 브라우저 렌더링 과정

### 가상 DOM의 탄생 배경

### 가상 DOM을 위한 아키텍처, 리액트 파이버

리액트 파이버의 목표 리액트 웹 어플리케이션에서 발생하는 애니메이션, 레이아웃, 사용자 인터렉션의 반응성 문제를 해결하는 것



### 파이버와 가상 DOM

## 클래스 컴포넌트와 함수 컴포넌트

함수 컴포넌트는 렌더링이 일어날 때마다 그 순간의 값인 props와 state를 기준으로 렌더링된다. props와 state가 변경된다면. 다시 한 번 그 값을 기준으로 함수가 호출된다고 볼 수 있다. 반면 클래스 컴포넌트는 시간의 흐름에 따라 변화하는 this를 기준으로 렌더링이 일어난다.

만약 이제 리액트를 배우기 시작했거나 새로운 리액트 프로젝트를 시작할 계획이라면 함수 컴포넌트로 작성하는 것이 당연히 좋다. 어느 정도 리액트에 익숙해졌다면 클래스 컴포넌트도 한 번쯤 공부해 볼 만하다. 리액트의 오랜 역사 동안 많은 코드들이 클래스 컴포넌트로 작성됐으며 이러한 흐름을 알기 위해서는 어느 정도의 클래스 컴포넌트에 대한 지식도 필요하다. 또한 앞서 봤듯이 일부 클래스 컴포넌트의 메서드. 특히 자식 컴포넌트에서 발생한 에러에 대한 처리는 현재 클래스 컴포넌트로만 가능하므로 에러 처리를 위해서라도 클 래스 컴포넌트에 대한 지식은 어느 정도 필요하다고 볼 수 있다.

### 클래스 컴포넌트

### 함수 컴포넌트

### 함수 컴포넌트 vs 클래스 컴포넌트

## 렌더링은 어떻게 일어나는가

리액트의 렌더링은 시간과 리소스를 소비해 수행되는 과정으로, 이 비용은 모두 웹 애플리케이션을 방문하는 사용자에게 청구되며, 시간이 길어지고 복잡해질수록 유저의 사용자 경험을 저해하기 때문이다. 따라서 리액트 개발자라면 렌더링이 어떻게, 왜. 어떤 순서로 일어나는지 알고 있어야 하며 이러한 렌더 링 과정을 최소한으로 줄여야 한다

### 렌더링이란?

리액트에서의 렌더링이란 리액트 애플리케이션 트리 안에 있는 모든 컴포넌트들이 현재 자신들이 가지고 있는 props와 state의 값을 기반으로 어떻게 내를 구성하고 이를 바탕으로 어떤 DOM 결과를 브라우저에 제공할 것인지 계산하는 일련의 과정을 의미

### 일어나는 이유

### 프로세스

### 렌더와 커밋

### 일반적인 렌더링 시나리오

## 메모이제이션

아직 리액트를 배우고 있거나 혹은 리액트를 깊이 이해하고 싶고, 이를 위해 시간을 투자할 여유가 있다면 1번의 의견대로 섣부른 메모이제이션을 지양하는 자세를 견지하면서 실제 어느 지점에서 성능상 이점을 누릴 수 있는지 살펴보는 식으로 메모이제이션을 적용하는 것을 권장한다. 이 책의 후반부에는 단순히 렌더링이 되는지 여부를 확인하는 방법뿐만 아니라 실제로 크롬 메모리 프로파일러로 분석하면서 state나 props의 변화에 따라 크롬 내부에서 어떤 일이 일어나는지 확인할 수 있는 방법도 제공한다. 이러한 방법으로 실제 웹 애플리케이션 성능에 어떠한 영향을 미치는지 꼼꼼하게 살펴보자. 이는 리액트에 대한 이해도와 웹 애플 리케이션에 대해 접근하는 관점을 넓히는 좋은 기회가 될 것이다.

### 주장 1. 섣부른 최적화는 독

메모이제이션을 활용한 최적화는 신중을 기해야 한다. 미리 개발자가 렌더링이 많이 될
것 같은 부분을 예측해 메모이제이션하는, 이른바 섣부른 최적화는 옳지 못한 행동이다. 일단 애플리케이션을 어느 정도 만든 이후에 개발자 도구나 useEffect를 사용해 실제로 어떻게 렌더링이 일어나고 있는지 확인하고 필요한 곳에서만 최적화하는 것이 옳다.

### 주장 2. 렌더링 과정의 비용은 비싸다

메모이제이션은 하지 않는 것보다 메모이제이션했을 때 더 많은 이점을 누릴 수 있다. 이것이 비록 섣부른 초기화라 할지라도 했을 때 누릴 수 있는 이점, 그리고 이를 실수로 빠트렸을 때 치러야 할 위험 비용이 더 크기 때문에 최적화에 대한 확신이 없다면 가능한 한 모든 곳에 메모이제이션을 활용한 최적화를 하는 것이 좋다.